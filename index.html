<!doctype html>
<html ng-app="demoapp">
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.0/angular.min.js"></script>
    <script src="dist/progresspie.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        var app = angular.module("demoapp", ['ui-progresspie']);
        app.controller("BasicFirstController", [ "$scope", function($scope) {
            // Nothing here!
        }]);
    </script>
    <style>
    text {
      font-family: sans-serif;
      fill: #666;
      font-weight: 100;
    }
    </style>
  </head>
  <body ng-controller="BasicFirstController">
    <div>
      <div progresspie></div>
    </div>
    <p>text goes here ok bye</p>
    <script>

    var width = 220,
        height = width,
        tau = 2 * Math.PI,
        radius = width / 2,
        actualInner = radius - (radius * 0.10),
        actualOuter = radius,
        gap = radius * 0.02,
        expectedOuter = actualInner - gap,
        expectedInner = radius - (radius * 0.17),
        circleRadius = radius * 0.7,
        fontSize = radius * 0.4;

    console.log("Actual Inner: " + actualInner);
    console.log("Actual Outer: " + actualOuter);
    console.log("Gap: " + gap);
    console.log("Expected Inner: " + expectedInner);
    console.log("Expected Outer: " + expectedOuter);
    console.log("Circle Radius: " + circleRadius);

    var actualArc = d3.svg.arc()
        .innerRadius(actualInner)
        .outerRadius(actualOuter)
        .cornerRadius(90)
        .startAngle(0);

    var expectedArc = d3.svg.arc()
        .innerRadius(expectedInner)
        .outerRadius(expectedOuter)
        .cornerRadius(90)
        .startAngle(0);


    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
      .append("g")
        .attr("transform", "translate(" + radius + "," + radius + ")")

    var centerCircle = svg.append("circle")
      .attr("cx", 0)
      .attr("cy", 0)
      .attr("r", circleRadius)
      .style("fill", "#000")
      .style("opacity", "0.05");

    var textGroup = svg.append("g")
    	.attr("alignment-baseline", "middle");

    var progressVal = textGroup
      .append("text")
        .attr("text-anchor", "middle")
      .append("tspan")
     	  .text("73")
        .attr("font-size", fontSize)
      .append("tspan")
        .attr("font-size", fontSize / 2)
     	  .text("%")

    var progressLabel = textGroup.append("text")
      .attr("font-size", fontSize / 2)
      .attr("transform", "translate(0, " + fontSize * 0.6 + ")")
      .attr("text-anchor", "middle")
     	  .text("Progress")



    var meters = svg.append("g");

    var actual = meters.append("path")
        .datum({endAngle: 0})
        .attr("d", actualArc)

    var expected = meters.append("path")
        .datum({endAngle: 0})
        .attr("d", expectedArc)
        .attr("opacity", "0.33");

    function setVal(expectedVal, actualVal) {
      actual.transition().duration(1000).call(arcTween, actualVal * tau, actualArc)
      expected.transition().duration(1000).call(arcTween, expectedVal * tau, expectedArc)
      meters.transition()
        .duration(1000)
        .tween("color", function() {
          var i = d3.interpolate("#F00", "#0F0")
          return function(t) { meters.attr("fill", i(t)); };
        });
    }



    // Creates a tween on the specified transition's "d" attribute, transitioning
    // any selected arcs from their current angle to the specified new angle.
    function arcTween(transition, newAngle, arc) {

      // The function passed to attrTween is invoked for each selected element when
      // the transition starts, and for each element returns the interpolator to use
      // over the course of transition. This function is thus responsible for
      // determining the starting angle of the transition (which is pulled from the
      // element's bound datum, d.endAngle), and the ending angle (simply the
      // newAngle argument to the enclosing function).
      transition.attrTween("d", function(d) {

        // To interpolate between the two angles, we use the default d3.interpolate.
        // (Internally, this maps to d3.interpolateNumber, since both of the
        // arguments to d3.interpolate are numbers.) The returned function takes a
        // single argument t and returns a number between the starting angle and the
        // ending angle. When t = 0, it returns d.endAngle; when t = 1, it returns
        // newAngle; and for 0 < t < 1 it returns an angle in-between.
        var interpolate = d3.interpolate(d.endAngle, newAngle);

        // The return value of the attrTween is also a function: the function that
        // we want to run for each tick of the transition. Because we used
        // attrTween("d"), the return value of this last function will be set to the
        // "d" attribute at every tick. (It's also possible to use transition.tween
        // to run arbitrary code for every tick, say if you want to set multiple
        // attributes from a single function.) The argument t ranges from 0, at the
        // start of the transition, to 1, at the end.
        return function(t) {

          // Calculate the current arc angle based on the transition time, t. Since
          // the t for the transition and the t for the interpolate both range from
          // 0 to 1, we can pass t directly to the interpolator.
          //
          // Note that the interpolated angle is written into the element's bound
          // data object! This is important: it means that if the transition were
          // interrupted, the data bound to the element would still be consistent
          // with its appearance. Whenever we start a new arc transition, the
          // correct starting angle can be inferred from the data.
          d.endAngle = interpolate(t);

          // Lastly, compute the arc path given the updated data! In effect, this
          // transition uses data-space interpolation: the data is interpolated
          // (that is, the end angle) rather than the path string itself.
          // Interpolating the angles in polar coordinates, rather than the raw path
          // string, produces valid intermediate arcs during the transition.
          return arc(d);
        };
      });
    }


    setVal(0.5, 0.74);









    </script>
  </body>
</html>
