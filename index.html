<!doctype html>
<html ng-app="demoapp">
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.0/angular.min.js"></script>
    <script src="dist/progresspie.js"></script>
    <script src="dist/simple.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        var app = angular.module("demoapp", ['ui-progresspie']);
        app.controller("BasicFirstController", [ "$scope", function($scope) {
            // Nothing here!
        }]);
    </script>
  </head>
  <body ng-controller="BasicFirstController">
    <div>
      <div progresspie></div>
    </div>
    <p>text goes here ok bye</p>
    <script>



var width = 960,
    height = 500,
    tau = 2 * Math.PI;

// An arc function with all values bound except the endAngle. So, to compute an
// SVG path string for a given angle, we pass an object with an endAngle
// property to the `arc` function, and it will return the corresponding string.
var actualArc = d3.svg.arc()
    .innerRadius(220)
    .outerRadius(240)
    .startAngle(0);

var expectedArc = d3.svg.arc()
    .innerRadius(180)
    .outerRadius(200)
    .startAngle(0);

// Create the SVG container, and apply a transform such that the origin is the
// center of the canvas. This way, we don't need to position arcs individually.
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")


var actual = svg.append("path")
    .datum({endAngle: 0, color: "#78c000"})
    .style("fill", "#78c000")
    .attr("d", actualArc)
    .attr("stroke-width", "10px")
    .attr("stroke", "#78c000")
    .attr("stroke-linejoin", "round");

var expected = svg.append("path")
    .datum({endAngle: 0, color: "#78c000"})
    .style("fill", "#78c000")
    .attr("d", expectedArc)
    .attr("stroke-width", "1px")
    .attr("stroke", "#78c000")
    .attr("stroke-linejoin", "round")
    .attr("opacity", "0.5");

function setVal(expectedVal, actualVal) {
  actual.transition().duration(1000).call(arcTween, actualVal * tau, actualArc)
  expected.transition().duration(1000).call(arcTween, expectedVal * tau, expectedArc)
  actual.transition()
    .duration(1000)
    .style("stroke", function() {
      return "red";
    });
}


function colorTween(transition, newColor, arc) {
  transition.attrTween("stroke", function(d) {
    //var interpolate = d3.interpolateRgb(d.color, newColor);
    var interpolate = d3.interpolateRgb.gamma(2.2)("purple", "orange");

    console.log(d);
    console.log(d.stroke);
    console.log(interpolate);
    return function(t) {

      d.stroke = interpolate(t);

      // Lastly, compute the arc path given the updated data! In effect, this
      // transition uses data-space interpolation: the data is interpolated
      // (that is, the end angle) rather than the path string itself.
      // Interpolating the angles in polar coordinates, rather than the raw path
      // string, produces valid intermediate arcs during the transition.
      return arc(d);
    };
  });

}


// Creates a tween on the specified transition's "d" attribute, transitioning
// any selected arcs from their current angle to the specified new angle.
function arcTween(transition, newAngle, arc) {

  // The function passed to attrTween is invoked for each selected element when
  // the transition starts, and for each element returns the interpolator to use
  // over the course of transition. This function is thus responsible for
  // determining the starting angle of the transition (which is pulled from the
  // element's bound datum, d.endAngle), and the ending angle (simply the
  // newAngle argument to the enclosing function).
  transition.attrTween("d", function(d) {

    // To interpolate between the two angles, we use the default d3.interpolate.
    // (Internally, this maps to d3.interpolateNumber, since both of the
    // arguments to d3.interpolate are numbers.) The returned function takes a
    // single argument t and returns a number between the starting angle and the
    // ending angle. When t = 0, it returns d.endAngle; when t = 1, it returns
    // newAngle; and for 0 < t < 1 it returns an angle in-between.
    var interpolate = d3.interpolate(d.endAngle, newAngle);

    // The return value of the attrTween is also a function: the function that
    // we want to run for each tick of the transition. Because we used
    // attrTween("d"), the return value of this last function will be set to the
    // "d" attribute at every tick. (It's also possible to use transition.tween
    // to run arbitrary code for every tick, say if you want to set multiple
    // attributes from a single function.) The argument t ranges from 0, at the
    // start of the transition, to 1, at the end.
    return function(t) {

      // Calculate the current arc angle based on the transition time, t. Since
      // the t for the transition and the t for the interpolate both range from
      // 0 to 1, we can pass t directly to the interpolator.
      //
      // Note that the interpolated angle is written into the element's bound
      // data object! This is important: it means that if the transition were
      // interrupted, the data bound to the element would still be consistent
      // with its appearance. Whenever we start a new arc transition, the
      // correct starting angle can be inferred from the data.
      d.endAngle = interpolate(t);

      // Lastly, compute the arc path given the updated data! In effect, this
      // transition uses data-space interpolation: the data is interpolated
      // (that is, the end angle) rather than the path string itself.
      // Interpolating the angles in polar coordinates, rather than the raw path
      // string, produces valid intermediate arcs during the transition.
      return arc(d);
    };
  });
}









    </script>
  </body>
</html>
